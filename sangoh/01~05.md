# 01장 프로그래밍

## 프로그래밍이란?

0과 1밖에 알지 못하는 기계가 실행할 수 있을 정도로 **정확하고 상세하게 요구사항을 설명**하는 작업

## 프로그래밍 언어
프로그래밍 언어를 사용해 프로그램을 작성 후, 컴파일러,  인터프리터로 컴퓨터가 이해할 수 있는 기계어로 변환해 컴퓨터로 전달한다.

<br/>

# 02장 자바스크립트
## 렌더링(rendering)
HTML, CSS, JS로 작성된 문서를 해석해서 브라우저에서 시각적으로 출력하는 것, 때로는 서버에서 데이터를 HTML로 변환해서 브라우저에게 전달하는 과정(SSR : Server Side Rendering)을 가르키기도 한다.

## Ajax
**서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 방식**

웹페이지에서 변경할 필요가 없는 부분은 다시 렌더링하지 않고, 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 렌더링하게 만듦

## Node.js
**자바스크립트 런타임 환경**

JS를 브라우저 이외 환경에서도 동작할 수 있도록 JS엔진을 브라우저에서 독립시킨 실행 환경
다양한 플랫폼에 적용 가능, 주로 서버 사이드 애플리케이션 개발에 주로 사용되며, 이에 필요한 모듈, 파일 시스템, HTTP 등 built-in API를 제공함

## 자바스크립트의 특징
1. 웹브라우저에서 동작하는 유일한 프로그래밍 언어
2. C, Java와 유사한 문법
3. 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어
4. 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어

## 인터프리터 언어 vs 컴파일러 언어
|컴파일러 언어|인터프리터 언어|
|-----|------|
|코드 실행 전 단계인 컴파일타임에 소스 코드 전체를 한번에 머신 코드로 변환한 후 실행한다.| 코드가 실행되는 단계인 런타임에 문 단위로 한 줄씩 중간 코드인 바이트 코드로 변환 후 실행|
실행 파일을 생산| 실행파일 생산 x|
컴파일 단계와 실행 단계가 분리. 명시적인 컴파일 단계를 거치고, 명시적으로 실팽 파일을 실행| 인터프리트 단계와 실행 단계가 분리되어 있지 않음. 인터프리터는 한 줄씩 바이트코드로 변환 후 즉시 실행|
실행에 앞서 컴파일은 단 한번 수행|코드가 실행될 때마다 인터프리트 과정이 반복 수행|
컴파일과 실행 단계가 분리되어 있으므로 코드 실행 속도가 빠름|인터 프리트 단계와 실행 단계가 분리되어 있지 않고 반복 수행되므로 코드 실행 속도가 비교적 느림|

# 3장 JS 개발 환경과 실행 방법
## 브라우저 VS Node.JS
- 브라우저 <br>HTML, CSS, JS 실행 웹페이지를 브라우저 화면에 렌더링하는 것이 주된 목적<br>

- Node.js <br>브라우저 외부에서 JS 실행환경을 제공하는 것이 주된 목적

브라우저는 Node.js와 다르게 파일을 생성,수정할 수 있는 파일 시스템을 제공하지 않는다<br>
➡️ 웹 애플리케이션의 JS는 사용자 컴퓨터의 브라우저에서 동작하는데 브라우저를 통해 다운로드되어 
실행되는 JS가 로컬 파일을 삭제, 수정, 생성 등의 보안상의 문제를 방지하기위해 브라우저 환경의 JS는 파일시스템을 제공하지 않음

# 4장 변수
## 선언
**하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름**
<br/>➡️ 메모리 값이 들어있는 **메모리 주소의 이름표를 붙이는 것**

변수 선언시 아무런 값을 할당하지 않는 다면 `undefined` 값이 할당됨

### 호이스팅 
**선언문이 코드 맨 위로 끌어 올려진 것처럼 동작하는 JS 고유의 특징**

JS엔진은 인터프리터로 소스코드를 순차적으로 실행하기 전 실행을 위한 준비 단계인 
소스코드의 평가 과정에서 <br/> **모든 선언문을 먼저 실행**하는데 이 과정에서 
선언된 식별자가 `undefined`가 할당되는 호이스팅이 발생한다

#### var
`let`, `const`도 호이스팅이 발생하지만, 변수가 선언되기전에 변수를 참조하면 `RefeenceError` 발생
<br/>`var`로 변수를 선언시 선언이 어느 곳에서 일어나는지 상관없이 호이스팅이 발생해 `undefined`로 참조 가능

## 할당
**변수에 값을 저장**
`let 변수 = 값` 현재 코드는 변수 선언과 동시에 값을 할당하는 것으로 보이지만
<br/>JS엔진 특성상 **변수 선언은 소스코드가 순차적으로 실행되는 런타임 이전에 먼저 실행**되기 때문에

1. 선언 ➡️ `let 변수`  
현재 변수(메모리 주소)에는 `undefined` 값이 저장되어있음
2. 할당 ➡️ `변수 = 값` 
<br/>`undefined` 값이 들어있는 메모리를 초기화후 값을 저장하는 것이 아니라 
새로운 메모리 공간을 확보 후 그곳에 값을 저장한다

위와 같은 과정을 거쳐 선언과 할당이 이뤄진다

### 재할당
값이 할당되어있는 변수에 값을 재할당하면 기존값은 더 이상 불필요하므로 
가비지 콜렉터에 의해 메모리에서 자동으로 해제됨
<br/>➡️ 이런식으로 메모리 관리를 언어 차원에서 담당하는 경우 매니지드 언어라고 한다


# 5장 표현식과 문

## 값
**표현식이 평가되어 생성된 결과**
<br/>평가 : 식을 해석해서 값을 생성하거나 참조하는 것
<br/>ex) `10 + 20;` ➡️  10 + 20이 평가되어 숫자 값 30 생성

## 리터럴
**사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법**
<br/>ex) `5` ➡️ 사람이 이해할 수 있는 숫자를 사용해 코드에 기술하면 숫자 리터럴 5가 생성됨

## 표현식
**값으로 평가될 수 있는 문장, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조**
```javascript
// 리터럴 표현식
10
'Hello'

// 식별자 표현식
sum
arr[1]

// 연산자 표현식
10 + 20
sum = 10

// 함수, 메서드 호출 표현식
square()
s.getnumber()
```
위와 같은 표현식은 값으로 평가되고
`표현식` === `표현식이 평가된 값` 이라고 할 수 있음

## 문
**여러 토큰으로 구성된 프로그램을 구성하는 기본 단위이자 최소 실행 단위**
<br/>토큰 : 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소 (키워드, 식별자, 연산자, 리터럴 등)
- 표현식이 아닌 문 : 평가될 수 없는 문 ➡️ `let x;` 와 같은 선언문은 평가될 수 없으므로 표현식이 아님
- 표현식인 문 : 평가 가능한 문 ➡️ 평가되어 값이 있는 문
