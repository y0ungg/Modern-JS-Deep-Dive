# Week 1 (7/6 ~ 7/10)
###### `Programming` `JavaScript`

<br />


## 1. 프로그래밍의 목적은 문제 해결이다
<br />

사람의 `프로그래밍 언어` ↔️ `컴파일러` ↔️ 컴퓨터의 `기계어`

<br />

1. 문제를 해결할 때 컴퓨터의 입장에서 문제를 바라봐야 한다. => **컴퓨팅 사고**
2. 코드로 정확하고 상세하게 요구사항을 설명해야 한다.
3. 요구사항(**문제 해결**)이 실현되어야 의미가 있다.

<br />


프로그래밍 언어는 **syntax**와 **sementics**의 조합으로 표현된다. 
**문법**에 맞는 문장을 구성하고, **의미**를 가지고 있어야 그 역할을 충실히 수행할 수 있다.

<br />
<br />

## 2. 자바스크립트의 등장과 표준화
<br />

1995년 넷스케이프 커뮤니케이션즈에서 **웹페이지의 보조적인 기능을 수행하기 위해 브라우저에서 동작하는 경량 프로그래밍 언어**를 도입하기로 결정했다.

1996년 넷스케이프 내비게이터에서 `Mocha`로 명명되었고, 이후 `라이브스크립트`를 거쳐 `자바스크립트` 라는 이름으로 최종 명명되었다.

1996년 8월 마이크로소프트에서 자바스크립트의 파생 버전인 `Jscript`를 출시하고, 넷스케이프와 마이크로소프트는 자사 브라우저에서만 동작하는 기능을 경쟁적으로 추가하기 시작했다.
이로 인해 브라우저에 따라 웹페이지가 정상적으로 동작하지 않는 **크로스 브라우징 이슈**가 발생하기 시작했다.

>자바스크립트의 파편화를 방지하고 모든 브라우저에서 정상적으로 동작하는 표준화된 자바스크립트의 필요성이 대두된다.

1996년 11월 넷스케이프에서는 컴퓨터 시스템 비영리 표준화 기구 **ECMA**에 **`자바스크립트`의 표준화**를 요청했다.

그 후 1997년 7월`ECMAScript 1`이라는 이름으로 표준화된 자바스크립트 초판이 출시된다.

초창기 `자바스크립트`는 **웹 페이지의 보조적인 기능을 수행하기 위해 한정적인 용도**로 사용되었다.

<br />

### 자바스크립트의 특징

1. 웹 브라우저에서 동작하는 유일한 프로그래밍 언어다.
2. 기본 문법은 `C`, `Java`와 유사하고 `Self`의 프로토타입 기반 상속을, `Scheme`의 일급 함수 개념을 사용했다.
3. 개발자가 별도의 컴파일 작업을 수행하지 않는 **인터프리터 언어**다.
> 모던 자바스크립트 엔진은 **인터프리터와 컴파일러의 장점을 결합**해 비교적 처리 속도가 느린 인터프리터의 단점을 해결했다.
> **인터프리터**는 소스코드를 즉시 실행하고, **컴파일러**는 빠르게 동작하는 머신 코드를 생성하고 최적화한다.
4. 명령형, 함수형, 프로토타입 기반 객체 지향 프로그래밍을 지원하는 **멀티 패러다임 프로그래밍 언어**다.

<br />
<br />

## 3. 자바스크립트 개발 환경
<br />

모든 브라우저와 Node.js는 자바스크립트 엔진을 내장하고, ECMAScript를 지원한다.

브라우저는 웹 페이지를 브라우저 화면에 렌더링하는 것이 주된 목적이지만,
Node.js는 브라우저 외부에서 자바스크립트 실행 환경을 제공하는 것이 주된 목적이다.

Node.js는 DOM API를 제공하지 않고, 고유의 API를 지원한다.
브라우저에서는 file system을 제공하지 않고, 다양한 클라이언트 사이드 Web API를 지원한다.

<br />
<br />

## 4. 변수
<br />

>메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체다.
메모리 셀 하나의 크기는 1byte = 8bit다.
컴퓨터는 메모리 셀의 크기(1byte)의 단위로 데이터를 저장하거나 읽어들인다.
각 셀은 메모리 주소를 갖는다.

메모리 주소를 통해 값에 직접 접근하는 것은 올바른 방법이 아니며 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다. (**Managed Language**)

프로그래밍 언어는 **기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위한 `변수`라는 매커니즘**을 제공한다.

<br>
<br>

`변수`는 **메모리 공간에 하나의 값을 저장하고 참조하는 매커니즘으로, 값의 위치를 가리키는 상징적인 이름**이다.

`변수`의 이름은 `식별자(Identifier)` 라고도 하며, `키워드`와 함께 `선언`함으로써 자바스크립트 엔진에 `식별자`의 이름을 알린다.
선언하지 않은 `식별자`에 접근하면 **ReferenceError**가 발생한다.

>모든 식별자는 각각의 네이밍 규칙을 준수해야 한다.

<br />

### 변수 선언과 할당
1. 선언 단계: 식별자를 선언한다.
2. 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고, `undefined`를 할당한다.

<br />

`변수 선언문`은 호이스팅 되어 `변수`의 runtime 이전에 실행된다.
`선언`은 호이스팅 되지만, 값의 `할당`은 runtime에 실행된다.

`변수`는 값을 재할당할 수 있고, `상수`는 값을 단 한 번만 할당할 수 있는 `변수`다.

<br />
<br />

## 5. 표현식과 문

<br />

#### 값 (value)
`표현식`이 `평가`되어 생성된 `결과`를 말한다.
`평가`: 식을 해석해서 값을 생성하거나 참조하는 것

#### 리터럴 (literal)
사람이 이해할 수 있는 `문자` 또는 약속된 `기호`를 사용해 값을 생성하는 `표기법`


#### 표현식 (expression)
`값`으로 평가될 수 있는 `문`
표현식이 평가되면 새로운 문을 생성하거나 기존값을 참조한다.


#### 문 (statement)
프로그램을 구성하는 기본 단위이자 최소 단위
여러 `토큰`으로 구성된다.
`토큰`: 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소

    let a = 5; //statement
    //token: let, a, =, 5, ; 

>세미콜론: 문의 종료를 나타낸다.
>`if문`, `for문`, `함수` 등의 `{중괄호}` 코드 블록은 **자체 종결성**을 갖기 때문에 세미콜론을 붙이지 않는다.