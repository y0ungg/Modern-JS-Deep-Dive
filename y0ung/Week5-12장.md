# Week 5 (8/1 ~ 8/7)
###### `JavaScript`

## 12. 함수

<br/>

### 📌 함수란?

일련의 과정을 문으로 구현하고 코드블록으로 감싸서 하나의 실행 단위로 정의한 것
함수 정의를 통해 생성하고, 함수 호출을 통해 실행한다.
함수를 실행하면 실행 결과를 반환한다.

#### 함수를 사용하는 이유
- 동일한 작업을 반복적으로 수행하는 코드를 함수로 만들어서 중복을 제거하고 코드를 재사용할 수 있다.
- 유지보수의 편의성을 높이고, 코드의 신뢰성을 높인다.
- 함수에 적절한 이름을 붙임으로써 코드의 가독성을 향상시킨다.

<br/>

### 📌 함수 리터럴
자바스크립트의 함수는 객체다. 객체를 객체 리터럴로 생성할 수 있는 것처럼 함수도 함수 리터럴로 생성할 수 있다. 또한, 함수를 변수에 할당할 수 있다. 

```jsx
//변수에 함수 리터럴을 할당
//기명 함수 표현식(named function expression)
const myFunc = function add(x, y) {
	return x + y;
}
```
위와 같이 함수 리터럴을 변수에 할당하면 변수는 함수명이 아닌 **함수가 할당된 참조값을 저장**하게 된다.
따라서 함수 호출시 함수명이 아닌, 함수를 가리키는 변수를 호출해야 한다.
함수명은 함수 몸체 내에서만 참조할 수 있는 식별자다.

```jsx
myFunc(1,2) //3
add(1,2) //Uncaught ReferenceError: add is not defined
```

>익명 함수 표현식은 함수명을 생략하고 할당한다.
>=>일반적인 함수 표현식

<br/>

### 📌 함수 정의


#### 1. 함수 선언문
함수 선언문은 표현식이 아닌 문이다.
따라서 함수 선언문을 실행하면 완료값 `undefined`가 출력된다.

또한, 표현식이 아닌 문이기 때문에 변수에 할당할 수 없다.

```jsx
function add(x,y) {
	return x + y;
}
//undefined
```

자바스크립트 엔진은 **코드의 문맥에 따라** 함수 리터럴 또는 함수 선언문으로 해석을 달리 한다.
함수 이름이 있는 `함수 리터럴`을 단독으로 사용하면 `함수 선언문`으로 해성하고,
함수 리터럴이 **값으로 평가**되어야 하는 문맥은 `함수 리터럴 표현식`으로 해석한다.

>함수 `add`를 호출하는 것은, 함수명을 호출하는 것이 아닌 자바스크립트 엔진에 의해 암묵적으로 생성된 식별자 `add`를 호출하는 것이다.

자바스크립트 엔진은 `함수 선언문`의 **함수 이름으로 식별자를 암묵적 생성**하고, 생성된 함수 객체를 할당한다.

이는 `함수 표현식`과 유사하게 동작하는 것처럼 보이지만 `함수 선언문`과 `함수 표현식`이 정확히 동일하게 동작하지는 않는다.



<br/>

#### 2. 함수 표현식
```jsx
//변수에 함수 리터럴을 할당
//익명 함수 표현식(anonymous function expression)
const add = function(x,y) {
	return x + y;
}
```

익명 함수를 호출하기 위해 함수를 가리키는 식별자 `add`를 호출한다.



<br/>

#### 3. 함수 생성 시점과 함수 호이스팅

함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다. (=함수 호이스팅이 일어난다.)
함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.

함수 선언문과 함수 표현식으로 정의된 각각의 함수가 생성되는 시점이 다르기 때문이다.

선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다.
그리고, 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 함수 객체를 할당한다.

이를 **함수 호이스팅**이라고 한다.

변수 선언문과 함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자를 생성한다는 점이 동일하지만,
`var` 키워드로 생성된 변수는 `undefined`로 초기화 되고, 함수 선언문을 통해 암묵적으로 생성된 식별자는 `함수 객체`로 초기화 된다.

따라서 변수 선언문 이전에 변수를 참조하면 `undefined`로 평가되지만, 함수 선언문 이전에 함수를 호출하는 것은 가능하다.

함수 표현식은 변수 선언과 할당이 한꺼번에 일어나는 표현식이다. 따라서 변수 호이스팅이 일어나서 `undefined`로 평가된다. (TypeError 발생)

함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시하는 일이므로, 호이스팅을 의도한 코드를 작성하는 것은 바람직하지 않다.

>변수 선언은 `undefined`로 초기화 되지만, 변수 할당은 런타임에 일어난다.
