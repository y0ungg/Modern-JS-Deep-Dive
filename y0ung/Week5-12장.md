# Week 5 (8/1 ~ 8/7)
###### `JavaScript`

## 12. 함수

<br/>

### 📌 함수란?

일련의 과정을 문으로 구현하고 코드블록으로 감싸서 하나의 실행 단위로 정의한 것
함수 정의를 통해 생성하고, 함수 호출을 통해 실행한다.
함수를 실행하면 실행 결과를 반환한다.

#### 함수를 사용하는 이유
- 동일한 작업을 반복적으로 수행하는 코드를 함수로 만들어서 중복을 제거하고 코드를 재사용할 수 있다.
- 유지보수의 편의성을 높이고, 코드의 신뢰성을 높인다.
- 함수에 적절한 이름을 붙임으로써 코드의 가독성을 향상시킨다.

<br/>

### 📌 함수 리터럴
자바스크립트의 함수는 객체다. 객체를 객체 리터럴로 생성할 수 있는 것처럼 함수도 함수 리터럴로 생성할 수 있다. 또한, 함수를 변수에 할당할 수 있다. 

```jsx
//변수에 함수 리터럴을 할당
//기명 함수 표현식(named function expression)
const myFunc = function add(x, y) {
	return x + y;
}
```
위와 같이 함수 리터럴을 변수에 할당하면 변수는 함수명이 아닌 **함수가 할당된 참조값을 저장**하게 된다.
따라서 함수 호출시 함수명이 아닌, 함수를 가리키는 변수를 호출해야 한다.
함수명은 함수 몸체 내에서만 참조할 수 있는 식별자다.

```jsx
myFunc(1,2) //3
add(1,2) //Uncaught ReferenceError: add is not defined
```

>익명 함수 표현식은 함수명을 생략하고 할당한다.
>=>일반적인 함수 표현식

<br/>

### 📌 함수 정의


#### 1. 함수 선언문
함수 선언문은 표현식이 아닌 문이다.
따라서 함수 선언문을 실행하면 완료값 `undefined`가 출력된다.

또한, 표현식이 아닌 문이기 때문에 변수에 할당할 수 없다.

```jsx
function add(x,y) {
	return x + y;
}
//undefined
```

자바스크립트 엔진은 **코드의 문맥에 따라** 함수 리터럴 또는 함수 선언문으로 해석을 달리 한다.
함수 이름이 있는 `함수 리터럴`을 단독으로 사용하면 `함수 선언문`으로 해성하고,
함수 리터럴이 **값으로 평가**되어야 하는 문맥은 `함수 리터럴 표현식`으로 해석한다.

>함수 `add`를 호출하는 것은, 함수명을 호출하는 것이 아닌 자바스크립트 엔진에 의해 암묵적으로 생성된 식별자 `add`를 호출하는 것이다.

자바스크립트 엔진은 `함수 선언문`의 **함수 이름으로 식별자를 암묵적 생성**하고, 생성된 함수 객체를 할당한다.

이는 `함수 표현식`과 유사하게 동작하는 것처럼 보이지만 `함수 선언문`과 `함수 표현식`이 정확히 동일하게 동작하지는 않는다.



<br/>

#### 2. 함수 표현식
```jsx
//변수에 함수 리터럴을 할당
//익명 함수 표현식(anonymous function expression)
const add = function(x,y) {
	return x + y;
}
```

익명 함수를 호출하기 위해 함수를 가리키는 식별자 `add`를 호출한다.



<br/>

#### 3. 함수 생성 시점과 함수 호이스팅

함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다. (=함수 호이스팅이 일어난다.)
함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.

함수 선언문과 함수 표현식으로 정의된 각각의 함수가 생성되는 시점이 다르기 때문이다.

선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다.
그리고, 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 함수 객체를 할당한다.

이를 **함수 호이스팅**이라고 한다.

변수 선언문과 함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자를 생성한다는 점이 동일하지만,
`var` 키워드로 생성된 변수는 `undefined`로 초기화 되고, 함수 선언문을 통해 암묵적으로 생성된 식별자는 `함수 객체`로 초기화 된다.

따라서 변수 선언문 이전에 변수를 참조하면 `undefined`로 평가되지만, 함수 선언문 이전에 함수를 호출하는 것은 가능하다.

함수 표현식은 변수 선언과 할당이 한꺼번에 일어나는 표현식이다. 따라서 변수 호이스팅이 일어나서 `undefined`로 평가된다. (TypeError 발생)

함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시하는 일이므로, 호이스팅을 의도한 코드를 작성하는 것은 바람직하지 않다.

>변수 선언은 `undefined`로 초기화 되지만, 변수 할당은 런타임에 일어난다.

<br/>

#### 4. function 생성자 함수

```jsx
const add = new Funtcion('x', 'y', 'return x + y');
```
일반적이지 않은 방식이라고 할 수 있다.
클로저를 생성하지 않고, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.

#### 5. 화살표 함수

```jsx
const add = (x,y) => x + y;
```

생성자 함수로 사용할 수 없으며, 기존 함수와 this 바인딩 방식이 다르다.
또한 prototype이 없고 arguments 객체를 생성하지 않는다.


<br/>
<br/>


### 📌 함수 호출

- 인수가 부족해서 할당되지 않은 매개변수의 값은 `undefined`다.
- 매개변수보다 인수가 많은 경우 초과된 인수는 무시된다.
- ES6에서 도입된 **매개변수 기본값**은 매개변수에 인수가 전달되지 않았을 경우나 `undefined`가 전달된 경우 유효하다.
```jsx
const add = (x=0, y=0, z=1) => x + y + z;

add(3,4) //8
```

- 매개변수의 개수나 순서가 변경되면 함수의 호출 방법도 바뀌므로 함수를 사용하는 코드 전체가 영향을 받는다.
따라서 이상적인 매개변수 개수는 0개이며, 최대 3개를 넘지 않는 것을 권장한다.
그 이상의 매개변수가 필요하다면 객체를 인수로 전달하는 것이 유리하다.

- 반환문 return을 생략하면 암묵적으로 `undefined`가 반환된다.
> Node.js는 모듈 시스템에 의해 파일별로 독립적인 파일 스코프를 갖는다. 따라서 가장 바깥 영역에 반환문을 사용해도 에러가 발생하지 않는다.
