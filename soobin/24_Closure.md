# ☑️ 24\_클로저

p.388~416

✍️ 2023.02.20(Mon)

- `A closure is the combination of a function and the lexical environment within which that function was declared.`
- = 클로저는 함수와 <u>함수가 선언된 렉시컬 환경</u>과의 조합

👀 `렉시컬 환경`: 함수가 정의된 위치의 스코프, 즉 상위 스코프를 의미하는 실행 컨텍스트의 렉시컬 환경

```js
const x = 1;

function outerFunc() {
  const x = 10;

  // 중첩 함수
  function innerFunc() {
    console.log(x); // 10  <- outerFunc의 x 변수에 접근 가능
  }

  innerFunc();
}

// 중첩 함수 innerFunc의 상위 스코프: 외부 함수 outerFunc의 스코프

OuterFunc();
```

<br/>

## 📎 24.1\_렉시컬 스코프

👀 `렉시컬 스코프(정적 스코프)`: 자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 <u>함수를 어디에 정의했는지</u>에 따라 상위 스코프 결정

👉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정됨.

<br/>

## 📎 24.2\_함수 객체의 내부 슬롯 [[Environment]]

- 함수는 자신의 내부 슬롯 [[Environment]]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장함.

- 함수 정의가 평가되어 함수 객체를 생성할 때 자신이 정의된 환경에 의해 결정된 상위 스코프의 참조를 함수 객체 자신의 내부 슬롯 [[Environment]]에 저장함.

- 이때 자신의 내부 슬롯에 저장된 상위 스코프의 참조는 현재 실행 중인 실행 컨텍스트의 렉시컬 환경을 가리킴.

- `상위 스코프`: 함수 객체의 내부 슬롯 [[Environment]]에 저장된 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조

<br/>

## 📎 24.3\_클로저와 렉시컬 환경

- `클로저`: 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수 참조가 가능한데, 이러한 중첩 함수가 바로 `클로져`

- `함수의 실행 컨텍스트`는 실행 컨텍스트 스택에서 제거되지만 함수의 렉시컬 환경까지 소멸하는 것은 아님.

- 중첩 함수 내부에서는 상위 스코프를 참조할 수 있으므로 상위 스코프의 식별자를 참조할 수 있고, 식별자의 값 변경도 가능

- 상위 스코프의 어떤 식별자도 참조하지 않는 함수는 클로저 ❌

- 클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고, 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적

- `자유 변수`: 클로저에 의해 참조되는 상위 스코프의 변수

- `클로저`란? '함수가 자유 변수에 대해 닫혀있다'라는 의미 👉 <u>자유 변수에 묶여있는 함수</u>

<br/>

## 📎 24.4\_클로저의 활용

- 클로저는 상태(state)를 안전하게 변경하고 유지하기 위해 사용함 👉 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용

```js
// 상태 변경 함수
const increase = (function () {
  let num = 0; // 상태 변수

  // 클로저
  return function () {
    return ++num;
  };
})();

// 즉시 실행 함수는 호출된 이후 소멸되지만 즉시 실행 함수가 반환한 클로저는 increase 변수에 할당되어 호출됨
// 즉시 실행 함수는 1번만 실행되므로 increase가 호출될 때마다 num 변수가 다시 초기화될 일은 없음

console.log(increase()); / 1
console.log(increase()); / 2
console.log(increase()); / 3
```

```js
const counter = (function () {
  let num = 0;

  return {
    increase() {
      return ++num;
    },

    decrease() {
      return num > 0 ? --num : 0;
    },
  };
})();
```

<br/>

## 📎 24.5\_캡슐화와 정보 은닉

- `캡슐화(encapsulation)`: 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것

- `정보 은닉`: 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용 <br/>
  👉 적절치 못한 접근으로부터 객체의 상태가 변경되는 것을 방지해 정보를 보호하고, 객체 간의 상호 의존성, 즉 결합도(coupling) ⬇️

```js
var funcs = [];

// i 변수: 함수 레벨 스코프를 갖기 때문에 전역 변수
for (var i = 0; i < 3; i++) {
  funcs[i] = function () {
    return i; // 3
  };
}

for (var i = 0; i < 3; i++) {
  funcs[i] = function (id) {
    return function () {
      return id;
    };
  }(id));
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]());
}
```

- for문의 변수 선언문에서 let 키워드로 선언한 변수를 사용하면 for문의 코드 블록이 반복 실행될 때마다 for문 코드 블록의 새로운 렉시컬 환경이 생성됨.
