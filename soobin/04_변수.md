# ☑️ 4. 변수

✍️ 2022.07.08(Fri)

## 📎 4.1\_변수란?

- 🖥 컴퓨터는 <u>CPU</u>를 사용하여 연산하고, <u>메모리</u>를 사용하여 데이터 기억

> 🧐 <i><strong>Memory</strong></i>란? <br/>
> : 데이터를 저장할 수 있는 메모리 cell 집합체 <br/><br/>
> ⌘ 메모리 셀 하나 크기: `1byte(8bit)` <br/>
> 👉 🖥 컴퓨터는 `1byte` 단위로 데이터 저장 및 Read <br/><br/>
> ⌘ 각 셀은 고유한 <u>메모리 주소</u>(메모리 공간 위치)를 갖음

- 🖥 컴퓨터는 모든 데이터를 2진수로 처리 <br/>
  👉 메모리에 저장되는 데이터는 모두 2진수로 저장

- JS는 개발자의 직접적인 메모리 제어 허용 ❌ <br/>
  👉 변수 사용 (🤷‍♀️ why? 기억하고 싶은 값을 메모리에 저장하고, 재사용하기 위해)

<br/>

> 🧐 <i><strong>변수(variable)</strong></i>란? <br/>
> ➰ 값을 저장하기 위해 확보한 메모리 공간 <br/>
> ➰ 그 메모리 공간을 식별하기 위해 붙인 이름 <br/>
> 👉 즉, 값을 저장하고 참조하는 메커니즘으로, 값의 위치를 가리키는 상징적인 이름 <br/> <br/>
> ⌘ 변수는 컴파일러/인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행 <br/>
> 👉 안전하게 값에 접근 가능! <br/><br/>
> ✋ 변수는 하나의 값만 저장 가능하므로, 여러 값들을 저장하려면 여러 개의 변수를 사용해야 함<br/>
> 👉 단, 배열 및 객체를 사용하면 여러 값들을 그룹화해서 하나의 값처럼 사용 가능

<br/>

## 📎 4.2\_식별자(identifier)

> 🧐 <i><strong>식별자</strong></i> 란? <br/>
> : 변수 이름이자, 어떤 값을 구별해서 식별할 수 있는 고유한 이름 👉 메모리 주소에 붙인 이름

- 값은 메모리 공간에 저장됨<br/>
  👉 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별하여 식별<br/>
  ✋ 식별자는 값이 아니라 그 값이 저장되어 있는 <u>메모리 주소</u>를 기억(저장)해야 함!

- ✎ 식별자는 값이 저장되어 있는 메모리 주소와 mapping 관계이며, 이 매핑 정보도 메모리에 저장되어야 함

<br/>

## 📎 4.3\_변수 선언(variable declaration)

- 변수 선언 = 변수 생성
- 변수를 사용하려면 반드시 선언 필요!

> 🧐 `Var` keyword
>
> - block-level scope 지원 ❌
> - function-level scope 지원 ⭕️ <br/>
>   👉 의도치 않게 전역 변수 선언 → 심각한 부작용 발생 😨

<br/>

📈 <strong>JS엔진의 변수 선언 단계</strong>

1. 선언 단계: 변수 이름을 등록해서 JS엔진에 변수 존재 알림
2. 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화 <br/>

   ✚ 초기화란? 변수가 선언된 이후 최초로 값을 할당하는 것 <br/>

   ✋ 선언, 초기화 단계 동시에 진행!

<br/>

- If ❗️초기화 단계 👉 확보된 메모리 공간에는 이전 사용 값이 남아 있을 수 있음 👉 `Garbage Value`

- If 선언하지 않은 식별자에 접근하면 `ReferenceError(참조 에러)` 발생
- `ReferenceError(참조 에러)`: 식별자를 통해 값을 참조하려 했지만 JS엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 Error

<br/>

✍️ 2022.07.11(Mon)

## 📎 4.4\_변수 선언의 실행 시점 & 변수 호이스팅

```js
console.log(score); // undefined
var score; // 변수 선언문
```

⌘ JS는 인터프리터에 의해 한 줄씩 순차적으로 실행 <br/>
⌘ 변수 선언이 소스코드가 순차적으로 실행되는 런타임 이전 단계에서 먼저 실행 <br/>
👉 참조 에러가 아닌 `undefined` 출력

🙌 즉, 어디서든지 변수 참조 가능

<br/>

> 🧐 <i><strong>변수 호이스팅(variable hoisting)</strong></i> 란? <br/>
> : 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 JS 고유 특징 <br/>
> ➰ 모든 선언문은 런타임 이전 단계에서 먼저 실행됨

<br/>

## 📎 4.5\_값의 할당

⌘ 변수에 값을 할당(assignment)할 땐 <u>할당 연산자</u>(우변 값을 좌변 변수에 할당)인 `=` 사용

```js
var score; // 변수 선언
score = 100; // 값 할당

// 단축 표현
var score = 100;
```

✋ 변수 선언과 값 할당의 실행 시점이 다름

- 변수 선언: 런타임 이전에 먼저 실행
- 값 할당: 런타임에 실행 <br/>
  👉 즉, 변수 선언 후, 값이 `undefined`로 할당되고, 값을 할당하면 해당 값으로 값이 재할당되는 것!

✋ 변수에 값 할당시, 이전 값인 `undefined`가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값을 새롭게 저장하는 것이 아니라 <u>새로운 메모리 공간을 확보하고 그 곳에 할당 값을 저장</u>하는 것!!

<br/>

## 📎 4.6\_값의 재할당

- `var`로 선언한 변수는 값 재할당 가능

- `상수(constant)`는 한번 정해지면 변하지 않는 값으로, 단 1번만 할당할 수 있는 변수
  - `const` 키워드를 사용해 선언한 변수는 재할당 금지 ❌ <br/>
    ✋ 반드시 상수만을 위해 사용하는 건 아님

<br/>

- 재할당하면 그 이전의 값들은 `가비지 콜렉터`에 의해 메모리에서 자동 해제됨 <br/>
  (단, 메모리에서 언제 해제될지는 예측할 수 없음)

  ✎ 가비지 콜렉터(garbage collector) <br/>
  : 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능

<br/>

## 📎 4.7\_식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 문자, \_, $로 시작해야 함 (숫자 시작 ❌)
- 예약어는 식별자로 사용 ❌

  ```js
  // wrong example
  var first-name; // - 특수문자 사용
  var 1st; // 숫자로 시작
  var this; // 예약어 사용
  ```

- 변수는 쉼표로 구분해 하나의 문에 여러 개 한번에 선언 가능 (권장 🙅‍♀️)

  ```js
  var person, $elem, _name;
  ```

- JS는 대소문자 구별하므로 대소문자가 다르면 각각 별개의 변수임

> 🧐 <i><strong>네이밍 컨벤션(Naming Convention)</strong></i>이란? <br/>
> : 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해å 규정한 명명 규칙

1. camelCase
2. snake_case
3. PascalCase
4. typeHungarianCase

   ```js
   var strFirstName; // type + identifier
   ```

- 변수, 함수 이름 👉 camelCase
- 생성자 함수, 클래스 이름 👉 PascalCase
