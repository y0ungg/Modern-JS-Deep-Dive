# ☑️ 12. 함수

p.154~188

✍️ 2022.11.04(Fri)

## 📎 12.1\_함수란?

> 일련의 과정을 문으로 구현하고, 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것

- `매개변수(parameter)`: 함수 내부로 입력을 전달받는 변수
- `인수(argument)`: 입력
- `반환값(return value)`: 출력

<br/>

## 📎 12.3\_함수 리터럴

🙌 함수는 객체 타입의 값이므로 이름(식별자)을 붙일 수 있다.

- 함수 리터럴은 `function 키워드`, `함수 이름`, `매개 변수 목록`, `함수 몸체`로 구성됨

1. `함수 이름`
   - 함수 몸체 내에서만 참조할 수 있는 식별자 (식별자 네이밍 규칙 준수)
   - 함수 이름은 생략 가능
   - 기명 함수: 이름이 있는 함수
   - 무명/익명 함수: 이름이 없는 함수
2. `매개변수 목록`
   - 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분
   - 함수 호출시 지정한 인수가 순서대로 할당됨 (순서에 의미가 있음!)
   - 함수 몸체 내에서 변수와 동일하게 취급 (식별자 네이밍 규칙 준수)
3. `함수 몸체`
   - 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록
   - 함수 호출에 의해 실행됨

👀 함수는 객체다!!!

<br/>

## 📎 12.4\_함수 정의

> 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 반환할 값을 지정하는 것

### 💫 12.4.1\_함수 선언문

- 함수 선언문은 함수 리터럴과 형태 동일
- 단, 함수 선언문에서는 함수 이름 생략 불가능

```js
function add(x, y) {
  return x + y;
}
// 호출하지 않으면 함수 선언문 자체는 undefined <-  표현식이 아닌 문
```

### 💫 12.4.2\_함수 표현식

```js
var add = function add(x, y) {
  return x + y;
};

// 표현식이 아닌 문은 변수에 할당 X
// But, 위 함수 선언문은 변수에 할당되는 것처럼 보임
// why? 함수 선언문(표현식이 아닌 문)과 기명 함수 리터럴(표현식인 문) 형태가 동일
// so, 기명 함수 선언문이 함수 리터럴로 해석될 가능성이 있음
```

```js
// 기명 함수 리터럴 단독 사용 => 함수 선언문으로 해석
function foo() {
  console.log('foo');
}
// 호출 가능 (JS엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체 할당)
foo(); // foo

// 함수 리터럴을 피연산자로 사용 => 함수 리터럴 표현식으로 해석
(function bar() {
  console.log('bar');
}))
// 호출 불가능 (함수 이름 bar는 함수 몸체 내에서만 참조할 수 있는 식벽자이므로)
bar(); // ReferenceError
```

🙌 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출함

- `일급 객체`: 값의 성질을 갖는 객체 <br/>
  👉 JS 함수는 일급객체로 값처럼 자유롭게 사용 가능!

> 함수 리터럴로 생성한 함수 객체를 변수에 할당 가능 <br/>
> 이러한 방식이 `함수 표현식`!

```js
// 함수 표현식
var add = function (x, y) {
  return x + y;
};

// 기명 함수 표현식
var add = function foo(x, y) {
  return x + y;
};
// 함수 호출시엔 함수 이름이 아닌 함수 객체를 가리키는 식별자를 사용해야 함
add(2, 5); // 7
foo(2, 5); // ReferenceError
```

### 💫 12.4.3\_함수 생성 시점과 함수 호이스팅

```js
add(2, 5); // 7
sub(2, 5); // TypeError

// 함수 선언문 -> 이전에 호출 가능
function add(x, y) {
  return x + y;
}

// 함수 표현식 -> 이전에 호출 불가능
var sub = function (x, y) {
  return x - y;
};

// 각각 정의한 함수 생성 시점이 다르기 때문에 함수 정의 전 호출 가능 유무가 다르다.
```

- 함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성됨
- 또한, JS엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당함

👀 `함수 호이스팅(function hoisting)`: 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 JS 고유 특징

- 함수 표현식의 리터럴은 변수 할당과 마찬가지로 할당문이 실행되는 시점에 평가되어 함수 객체가 됨 <br/>
  → 함수 표현식으로 함수를 정의하면 함수 호이스팅이 아닌 변수 호이스팅이 발생 <br/>
  → 함수 표현식 이전에 함수 참조시 `undefined`로 평가 <br/>
  → 함수 호출시엔 TypeError 발생 <br/>
  👉 함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조/호출해야 함

### 💫 12.4.4_Function 생성자 함수

> `Function` 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성해서 반환함

```js
var add = new Function("x", "y", "return x + y");
add(2, 5); // 7
```

✋ 얜 클로저를 생성하지 않는 등 일반적이지 않으며 바람직하지 않으므로 지양..

### 💫 12.4.5\_화살표 함수

```js
const add = (x, y) => x + y;
```

## 📎 12.5\_함수 호출

- 함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 실행 흐름을 옮긴다.

### 💫 12.5.1\_매개변수와 인수

- 매개변수는 함수 몸체 내부에서만 참조 가능하며, 외부에선 참조 불가능 <br/>👉 매개변수의 스코프는 `함수 내부`
- 함수는 매개변수 개수와 인수 개수가 일치하는지 체크하지 않아서 개수가 달라도 에러를 발생하지 않고, `undefined`를 반환함
- 매개변수보다 인수가 더 많은 경우 초과된 인수는 무시됨

### 💫 12.5.3\_매개변수의 최대 개수

- 매개변수 개수는 적을수록 좋으며, 최대 3개 이상 넘지 않는 것을 권장!
- 여러 매개변수가 필요할 경우 객체를 인수로 전달하는 것도 괜츈쓰

### 💫 12.5.4\_반환문

#### 🧙‍♂️ 반환문 역할

1. 함수 실행을 중단하고 함수 몸체를 빠져나간다. 따라서 반환문 이후의 문은 실행되지 않고 무시
2. return 키워드 뒤에 오는 표현식을 평가해 반환한다. (지정하지 않으면 undefined 반환)

   ```js
   function foo() {
     return;
   }

   foo(); // undefined
   ```

<br/>

## 📎 12.6\_참조에 의한 전달과 외부 상태의 변경

```js
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = "Kim";
}

var num = 100;
var person = { name: "Choi" };

changeVal(num, person);
console.log(num); // 100 <- 원시 값은 원본 훼손 X
console.log(person); // {name: "Kim"} <- 객체는 원본 훼손 O
```

<br/>

## 📎 12.7\_다양한 함수의 형태

### 💫 12.7.1\_즉시 실행 함수

> 함수 정의와 동시에 즉시 호출되는 함수 (단 1번만 호출되면 다시 호출 불가)

```js
(function () {
  var a = 5;
  var b = 10;
  return a * b;
})();
```

- 익명 함수(이름 X)를 사용하는 것이 일반적
- 반드시 그룹 연산자(`()`)로 감싸야 함 (먼저 함수 리터럴을 평가해서 함수 객체를 생성하기 위함)
- 일반 함수처럼 값을 반환할 수 있고, 인수를 전달할 수도 있음

### 💫 12.7.2\_재귀 함수

> 자기 자신을 호출하는 행위 즉, 재귀 호출을 수행하는 함수

```js
function factorial(n) {
  // 탈출 조건이 없으면 함수 무한 호출 -> stack overflo 에러 발생
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}
```

### 💫 12.7.3\_중첩 함수

> 함수 내부에 정의된 함수

```js
// 외부함수(중첩함수를 포함하는 함수)
function outer() {
  var x = 1;

  // 중첩 함수
  funtion inner() {
    var y = 2;
    console.log(x + y); // 3
  }

  inner(); // 중첩 함수는 외부 함수 내부에서만 호출 가능
}
outer();
```

### 💫 12.7.4\_콜백 함수

> 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수

> `고차함수`: 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수

- 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.
- 콜백 함수는 고차 함수에 의해 호출되며, 이때 고차 함수는 필요에 따라 콜백 함수에 인수 전달 가능 <br/>
  ✋ 고차함수에 콜백 함수 전달시 콜백 함수를 호출하지 말고 함수 자체를 전달해야 함!

- 콜백 함수는 비동기 처리뿐만 아니라 배열 고차 함수에서도 사용됨 (ex. map, filter, reduce)

### 💫 12.7.5\_순수 함수와 비순수 함수

- `순수 함수`: 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수

  - 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수
  - 외부 상태에 의존하지 않고 내부 상태에만 의존한다 해도 내부 상태가 호출될 때마다 변화하는 값이라면 순수함수가 아님!
  - 최소 하나 이상의 인수를 전달받음
  - 인수를 변경하지 않는 것이 기본적 (인수의 불변성 유지)
  - 함수의 외부 상태를 변경하지 않음

    ```js
    var count = 0;

    function increase(n) {
      return ++n;
    }

    count = increase(count); // 1
    ```

<br/>

- `비순수 함수`: 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수

  - 함수의 외부 상태를 변경하는 부수효과 존재
  - 함수 내부에서 외부 상태를 직접 참조하지 않더라도 매개변수를 통해 객체를 전달받으면 비순수 함수!

    ```js
    var count = 0;

    function increase() {
      return ++count;
    }

    increase();
    console.log(count); // 1
    ```
