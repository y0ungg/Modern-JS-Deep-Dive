# ☑️ 15. let, const 키워드와 블록 레벨 스코프

p.208~218

✍️ 2022.11.27(Sun)

## 📎 15.1_var 키워드로 선언한 변수의 문제점

### 💫 15.1.1\_변수 중복 선언 허용

- var 키워드로 선언한 변수는 중복 선언 가능 ⌦ 먼저 선언된 값이 변경됨

### 💫 15.1.2\_함수 레벨 스코프

- var 키워드로 선언한 변수는 오직 <u>함수의 코드 블록</u>만을 지역 스코프로 인정 <br/>
  ⌦ 함수, for문 외부에서 var로 선언한 변수는 코드 블록 내에서 선언해도 모두 <u>전역 변수</u>!

  ```js
  var x = 1;
  if (true) {
    var x = 10; // x는 전역변수지만 의도치 않게 변수값이 1->10으로 변경
  }
  console.log(x); // 10
  ```

  ```js
  var i = 10;
  // for문 내 선언한 i는 전역 변수! (중복 선언)
  for (var i = 0; i < 5; i++) {
    console.log(i); // 0 1 2 3 4
  }
  console.log(i); // 5
  ```

### 💫 15.1.3\_변수 호이스팅

- var 키워드로 변수 선언시 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작 <br/>
  ⌦ 이 변수는 변수 선언문 이전에 참조 가능 <Br/>
  🖐 할당문 이전에 변수 참조시 항상 `undefined` 반환

```js
// 여기서 변수 호이스팅에 의해 이미 foo 변수가 선언됨
// 변수 foo -> undefined로 초기화됨
console.log(foo); // undefined

foo = 123; // 변수에 값 할당
console.log(foo); // 123

var foo; // 변수 선언은 런타임 이전에 자스엔진에 의해 암묵적으로 실행됨

// 즉, 런타임 이전에 선언 단계와 초기화 단계가 실행되고,
// 따라서 변수 선언문 이전에 변수를 참조할 수 있는 것!!
```

<br/>

## 📎 15.2_let 키워드

### 💫 15.2.1\_변수 중복 선언 금지

- let 키워드로 이름이 같은 변수를 중복 선언하면 `SyntaxError` 발생

### 💫 15.2.2\_블록 레벨 스코프

- let 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 `블록 레벨 스코프`!

### 💫 15.2.3\_변수 호이스팅

- let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작
- 이는 선언 단계 & 초기화 단계가 분리되어 진행됨
  - 선언 단계: 런타임 이전에 자스엔진에 의해 암묵적으로 먼저 실행
  - 초기화 단계: 변수 선언문에 도달했을 떄 실행 (실행 이전에 변수 접근시 참조에러 발생)

> 👉 `스코프 시작 지점 ~ 초기화 단계 시작 지점`까지 변수 참조할 수 없는 구간 <br/>
> ⌦ 일시적 사각지대(`Temporal Dead Zone`: `TDZ`)

```js
console.log(foo); // ReferenceError
// TDZ
let foo;
console.log(foo); // undefined

foo = 1;
console.log(foo); // 1
```

```js
let foo = 1; // 전역 변수

{
  // 변수 호이스팅이 발생하지 않는다면 아래에서 전역 변수 foo 값을 출력해야 함
  // but, 호이스팅이 발생하므로 참조 에러 발생
  console.log(foo); // ReferenceError
  let foo = 2;
}
```

🖐 JS는 ES6에서 도입된 모든 선언을 호이스팅하지만 let, const, class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작!

### 💫 15.2.4\_전역 객체와 let

- var와 달리 let 전역 변수는 보이지 않는 개념적인 블록 내에 존재하게 됨 (전역 객체 프로퍼티 X)

```js
let x = 1;

console.log(window.x); // undefined
console.log(x); // 1
```

<br/>

## 📎 15.3_const 키워드

- const 키워드: 상수를 선언하기 위해 사용 (But, 반드시 상수만을 위해 사용하는건 아님 🙅‍♀️)

### 💫 15.3.1\_선언과 초기화

- const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.

  ```js
  const foo = 1; // O
  const foo; // X -> SyntaxError
  ```

- const 키워드로 선언한 변수는 블록 레벨 스코프를 가지며, 변수 호이스팅이 발생하지 않는 것처럼 동작

  ```js
  {
    // 변수 호이스팅이 발생하지 않는 것처럼 동작
    console.log(foo); // ReferenceError
    const foo = 1;
    console.log(foo); // 1
  }

  // 블록 레벨 스코프
  console.log(foo); // ReferenceError
  ```

### 💫 15.3.2\_재할당 금지

- var, let과 달리 const는 재할당 금지 ❌

  ```js
  const foo = 1;
  foo = 2; // TypeError
  ```

### 💫 15.3.3\_상수

- `상수`: 재할당이 금지된 변수 (일반적으로 상수 이름은 대문자, 스네이크 케이스(`_`)로 표현)
  ```js
  const TAX_RATE = 0.1;
  ```
  > const로 선언된 변수에 원시값을 할당한 경우 원시값은 변경할 수 없는 값이며, const에 의해 재할당이 금지되므로 할당된 값을 변경할 수 없다.

### 💫 15.3.4_const 키워드와 객체

- const로 선언된 변수에 객체를 할당한 경우엔 값 변경 가능 <br/>
  ✋ 객체가 변경되더라도 변수에 할당된 참조 값은 변경 ❌

  ```js
  const person = {
    name: "Choi",
  };

  person.name = "Kim";

  console.log(person); // {name: 'Kim'}
  ```

<br/>

## 📎 15.4_var vs. let vs. const

👍 변수 선언엔 기본적으로 `const`를 사용하고, 재할당이 필요한 경우 `let`을 한정적으로 사용하는 것이 좋음!

- ES6를 사용한다면 `var` 사용 지양
- 재할당이 필요한 경우에 한정하여 `let` 사용 (변수 스코프는 최대한 좁게!)
- 변경이 발생하지 않고, 읽기 전용으로 사용하는(재할당x) 원시값과 객체엔 `const` 사용 지향!
